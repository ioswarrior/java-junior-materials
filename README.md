# java-junior-materials

Список технологий в приложении:
Java (Core и тд) <br>
Алгоритмы и структуры данных <br>
JUnit <br>
Maven/Gradle <br>
Паттерны проектирования <br>
Git <br>
JPA (Hibernate) <br>
Spring <br>

# Раздел - Java Core <br>

Java Core - базовые сведения о языке Java и связанных с языком технологий и возможностей.

## 1. О языке Java?

Java – строго типизированный объектно-ориентированный язык программирования. Его создали в 1995 году, и с того времени он получил много улучшений. Стабильно занимает лидирующие места в рейтингах языков программирования и в рейтингах зарплат разработчиков.

И самое главное – рейтинг Java не прыгает из года в год, а остается стабильно высоким.

Какие положительные качества у языка Java? - это предложение можно изменить.
1. Кроссплатформенность – написанный код транслируется в байт-код, который выполняет JVM. Существуют реализации JVM под самые разные платформы, и это означает, что написанный один раз код будет работать и на Windows, и на Linux, и на macOS, и даже на разной экзотике, такой как Arduino, умном холодильнике, пылесосе… То есть, код будет работать на разных платформах и операционных системах, и при этом его не нужно адаптировать под каждую из них.
2. Автоматическое управление памятью – разработчику не нужно думать о том, в каких адресах оперативной памяти хранятся переменные, вручную обеспечивать их чтение/запись и заботиться о целостности данных. Когда решаешь бизнес-задачу заказчика, нужно думать о задаче, а не о том, как и куда записать какие-то байты.
3. Скорость работы (just-in-time компилятор) – в дополнение к статической компиляции, которая происходит «заранее», работает динамическая компиляция. Это актуально для серверного кода, который может работать месяцами и даже годами. Код, который выполняется часто, компилируется разными вариантами и замеряется его время исполнения. Таким образом, чем дольше работает приложение, тем быстрее она работает. И это при активно работающем сервере. Круто, правда?

4. Обратная совместимость – код, написанный на более старых версиях Java, будет работать и на более новых версиях. Это удобно: после обновления не нужно переписывать половину проекта «ради обновления», и при этом можно получить последние патчи безопасности.

5. Объектно-ориентированность – человек мыслит объектами: стол, троллейбус, смартфон. Разработчику не нужно мыслить непривычными парадигмами во время работы, и это бережет наш код от лишних ошибок. Нужно концентрироваться только на тех деталях, которые важны в рамках задачи. Например, с точки зрения дизайнера интерьера важен размер стола и его положение в пространстве. Не важны дата его производства, фамилия рабочего, который выпилил этот стол, телефон курьера, который его доставлял. Кроме этого, в коде данные и методы работы с ними хранятся вместе.
6. Статическая типизация (fail-fast) – проверка соответствия типов переменных на этапе компиляции. Компиляцию запускают все разработчики, поэтому ошибки компиляции отлавливаются почти моментально. Чем более поздним будет этап, на котором обнаружат ошибку – тем дороже ее исправление.
7. Сode as documentation – Java читается как предложения на английском языке. За счет этого в большинстве случаев не нужно тратить усилия на ведение документации, так как любой разработчик, посмотрев в код, понимает, что делает этот метод, или за какое поведение отвечает интерфейс. Кроме этого, сильно развита практика «правильного» именования всех сущностей в коде. Часто по названию метода понятно, что он делает. 
Например, метод getContext() возвращает контекст, а поле age отвечает за хранение возраста. В Java длина названия не влияет на количество ресурсов системы, которые нужны для работы с сущностями. Этим грешит С – когда разработчик приходит на новый проект, вместо того, чтоб разбираться в логике кода, он занимается его расшифровкой.
8. Множество open source библиотек и фреймворков – 99% задач, с которыми в ежедневной практике сталкивается разработчик, уже кто-то когда-то решал. Если такие решения удачные, со временем они вырастают в библиотеки и даже фреймворки. Что лучше – погуглить 5 минут или изобретать свой велосипед на квадратных колесах?
9. Большое комьюнити – у популярного языка много разработчиков, они в интернете задают много вопросов, дают много ответов, пишут много кода, сталкиваются со многими проблемами и решают их. И чем больше разработчиков, тем более популярен язык, и тем быстрее он развивается. Замкнутый круг, однако.

Какие задачи можно решать на Java: (продолжение этого вопроса “всё о java”)

Разработка мобильных приложений для ОС Android; <br>
2. Разработка серверных приложений; <br>
3. Разработка desktop приложений; <br>
4. Приложения для встраиваемых устройств; <br>
5. Разработка веб-приложений. <br>

На Java можно разрабатывать что угодно:
высоконагруженные системы (Google, Yandex, Facebook были разработаны в том числе на Java); <br>
банковские веб-приложения (Сбер, Альфа Банк, ВТБ созданы руками Java-программистов); <br>
игры (Minecraft); <br>
искусственный интеллект (Watson, ViaVoice); <br>
мобильные приложения (Telegram и Signal); <br>
интернет-магазины (Ebay, Amazon). <br>


## 2. Чем различаются JRE, JVM и JDK?



1 вариант:

JVM, Java Virtual Machine (Виртуальная машина Java) — основная часть среды времени исполнения Java (JRE). Виртуальная машина Java исполняет байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java. JVM может также использоваться для выполнения программ, написанных на других языках программирования. 
JRE, Java Runtime Environment (Среда времени выполнения Java) - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из JVM и стандартного набора библиотек классов Java.
JDK, Java Development Kit (Комплект разработки на Java) - JRE и набор инструментов разработчика приложений на языке Java, включающий в себя компилятор Java, стандартные библиотеки классов Java, примеры, документацию, различные утилиты.
Коротко: JDK - среда для разработки программ на Java, включающая в себя JRE - среду для обеспечения запуска Java программ, которая в свою очередь содержит JVM - интерпретатор кода Java программ.

2 вариант:

Java Development Kit (JDK)  содержит необходимые библиотеки и подпрограммы для запуска, компиляции и отладки программ.
 
Таким образом, если мы в будущем хотим разрабатывать приложения на языке Java, нам нужен JDK.


Java Runtime Environment (JRE)
содержит виртуальную машину для запуска программ, стандартную библиотеку (готовые, уже написанные для нас компоненты) и ряд инструментов.

Она полезна, если мы хотим запустить готовую, уже скомпилированную программу.


## 3. Java компилируемый язык или интерпретируемый?
В Java используют гибридный подход: исходный код (текст программы) сначала компилируется в промежуточную форму с помощью компилятора, а затем исполняется с помощью JVM — виртуальной машины Java**:


## 4. Типы данных в Java?

В Java типы данных делят на две большие группы: примитивные и ссылочные. В состав примитивных типов (или просто примитивов) входят четыре подвида и восемь типов данных:
1) целые числа (byte, short, int, long);
2) числа с плавающей точкой (float, double);
3) логический (boolean);
4) символьный (char).
 
Ссылочные типы данных ещё называют ссылками. К ним относятся все классы, интерфейсы, массивы, а также тип данных String.
Хотя у примитивов и ссылок много общего, между ними есть существенные различия. И главное различие — в том, что именно в них хранится.




## 5. Что такое переменная?
1 вариант термина:

Переменная в Java — это контейнер, в котором может храниться некоторое значение данных для дальнейшего использования в программе.




2 вариант термина: 

переменная — это имя, с которым связано некоторое значение. Можно провести аналогию с контейнером (коробкой), в котором может храниться значение для дальнейшего использования в программе. Т.е. можно сравнить переменную с коробкой, в которой хранится какой-то предмет (в случае с программированием данный предмет — это значение переменной). Коробка может иметь надпись (имя переменной). А также для разных видов вещей могут использоваться разные виды коробок (вид коробки — тип переменной).

## 5. В чем разница между объектов и классом?
Первый вариант:

Класс - некая абстракция, логическая структура, описывающая поведение и характеристики.

Объект - конкретный экземпляр класса. Например, конкретный ваш дом.
Класс - шаблон, по которому создаются объекты
Класс описывается
Класс определяется единожды

Объект - экземпляр класса
Сущность из реального мира
Физическая сущность
Объект создается
Объект можно создавать, как правило, много раз
Второй вариант:

Класс – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт).
С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций для работы с ними (методов).
С точки зрения структуры программы, класс является сложным типом данных.
Объект (экземпляр) – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом. Каждый объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на основе правил, заданных в классе.

6. Что такое метод?
1 вариант:
Метод — это совокупность команд, позволяющая выполнить некоторую операцию в программе.
Иными словами, метод — это некоторая функция; что-то, что умеет делать твой класс.

2 вариант:
Методы в Java — это законченная последовательность действий (инструкций), направленных на решение отдельной задачи.

7. Что такое модификаторы доступа и какими они бывают?

Модификаторы доступа — это инструмент, при помощи которого можно настроить доступ к классам, методам и переменным.

Бывают следующие модификаторы, упорядоченные в порядке повышения доступа:

private — используется для методов, полей и конструкторов. Уровень доступа — только класс, внутри которого он объявлен.
package-private(default) — может использоваться для классов. Доступ только в конкретном пакете (package), в котором объявлен класс, метод, переменная, конструктор.
protected — такой же доступ, как и package-private + для тех классов, которые наследуются от класса с модификатором protected.
public — используется и для классов. Полноценный доступ во всем приложении.	



Раздел - ООП

8. Назовите основные принципы ООП?
Объектно-ориентированное программирование (ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

объектно-ориентированное программирование использует в качестве основных логических конструктивных элементов объекты, а не алгоритмы;
каждый объект является экземпляром определенного класса
классы образуют иерархии.
Программа считается объектно-ориентированной, только если выполнены все три указанных требования. В частности, программирование, не использующее наследование, называется не объектно-ориентированным, а программированием с помощью абстрактных типов данных.
Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, единственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить собственное состояние.

9. Назовите основные принципы ООП?
Абстракция
Наследование;
Инкапсуляция;
Полиморфизм;

10. Что такое наследование?

Наследование — это возможность создания новых классов на основе существующих.

Главная польза от наследования — повторное использование существующего кода.

Согласитесь, было бы неэффективно создавать какой-то класс, а потом проделывать всю работу заново для похожего класса. Гораздо рациональнее взять готовый класс, «клонировать» его, а затем внести добавления и обновления в полученном клоне. Это именно то, что вы получаете в результате наследования, с одним исключением - если изначальный класс (называемый также суперклассом или родительским классом) изменяется, то все изменения отражаются и на его «клоне» (называемом сабклассом или классом наследником).

Ключевое слово extends означает, что на основе существующего класса создается новый класс.

В большинстве объектных языков программирования класс может иметь только одного родителя. Но, с другой стороны, класс может реализовывать несколько интерфейсов одновременно. 

Ниже показано, каким образом определяется класс Cat, производный от класса Animal. Для обозначения наследования в Java служит ключевое слово extends.

public class Cat extends Animal {

}

Java не поддерживает наследование нескольких классов. Один класс - один родитель.

Класс-наследник будет иметь доступ ко всем полям и методам родителя. Это не совсем так. На самом деле, все методы и поляц, помеченные модификатором private, недоступны классу-наследнику.


второй вариант:
Наследование – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.
Класс, от которого производится наследование, называется предком, базовым или родительским. Новый класс – потомком, наследником или производным классом.
Представим себя, на минуту, инженерами автомобильного завода. Нашей задачей является разработка современного автомобиля. У нас уже есть предыдущая модель, которая отлично зарекомендовала себя в течение многолетнего использования. Всё бы хорошо, но времена и технологии меняются, а наш современный завод должен стремиться повышать удобство и комфорт выпускаемой продукции и соответствовать современным стандартам.
Нам необходимо выпустить целый модельный ряд автомобилей: седан, универсал и малолитражный хэтч-бэк. Очевидно, что мы не собираемся проектировать новый автомобиль с нуля, а, взяв за основу предыдущее поколение, внесём ряд конструктивных изменений. Например, добавим гидроусилитель руля и уменьшим зазоры между крыльями и крышкой капота, поставим противотуманные фонари. Кроме того, в каждой модели будет изменена форма кузова.
Очевидно, что все три модификации будут иметь большинство свойств прежней модели (старый добрый двигатель 1970 года, непробиваемая ходовая часть, зарекомендовавшая себя отличным образом на отечественных дорогах, коробку передач и т.д.). При этом каждая из моделей будет реализовать некоторую новую функциональность или конструктивную особенность. В данном случае, мы имеем дело с наследованием.


11. Что такое инкапсуляция?
 
Инкапсуляция – это свойство системы, позволяющее объединить данные и методы, работающие с ними в классе и скрыть детали реализации от пользователя. 

Расскажите, как работает поисковик Google. Как именно он ищет информацию по тем словам, которые вы ввели? Почему наверху находятся эти результаты, а не другие? 
 
Хотя вы пользуетесь гуглом каждый день, скорее всего, вы этого не знаете. Но это не важно. Ведь вам и не нужно этого знать.
 
Вы можете вводить запросы в поисковик не задумываясь, как именно он работает. Вы можете купить газировку в автомате, не зная как он устроен. Вы можете водить машину, не вникая в работу двигателя внутреннего сгорания, и вообще не зная физику даже на школьном уровне.
 
Все это возможно благодаря одному из главных принципов объектно-ориентированного программирования — инкапсуляции


12. Что такое полиформизм?
Полиморфизм — это возможность работать с несколькими типами так, будто это один и тот же тип. При этом поведение объектов будет разным в зависимости от того, к какому типу они принадлежат.

Полиморфизм – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого набора действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования. Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться по ссылке родительского типа).






Любое обучение вождению не имело бы смысла, если бы человек, научившийся водить, скажем, ВАЗ 2106 не мог потом водить ВАЗ 2110 или BMW X3. С другой стороны, трудно представить человека, который смог бы нормально управлять автомобилем, в котором педаль газа находится левее педали тормоза, а вместо руля – джойстик.
Всё дело в том, что основные элементы управления автомобиля имеют одну и ту же конструкцию, и принцип действия. Водитель точно знает, что для того, чтобы повернуть налево, он должен повернуть руль, независимо от того, есть там гидроусилитель или нет. Если человеку надо доехать с работы до дома, то он сядет за руль автомобиля и будет выполнять одни и те же действия, независимо от того, какой именно тип автомобиля он использует. По сути, можно сказать, что все автомобили имеют один и тот же интерфейс, а водитель, абстрагируясь от сущности автомобиля, работает именно с этим интерфейсом. Если водителю предстоит ехать по немецкому автобану, он, вероятно выберет быстрый автомобиль с низкой посадкой, а если предстоит возвращаться из отдалённого маральника в Горном Алтае после дождя, скорее всего, будет выбран УАЗ с армейскими мостами. Но, независимо от того, каким образом будет реализовываться движение и внутреннее функционирование машины, интерфейс останется прежним.

Принцип в ООП, когда программа может использовать объекты с одинаковым интерфейсом без информации о внутреннем устройстве объекта, называется полиморфизмом.





13. Что такое «абстракция»?
Абстрагирование – это способ выделить набор общих характеристик объекта, исключая из рассмотрения частные и незначимые. Соответственно, абстракция – это набор всех таких характеристик.

Представьте, что водитель едет в автомобиле по оживлённому участку движения. Понятно, что в этот момент он не будет задумываться о химическом составе краски автомобиля, особенностях взаимодействия шестерёнок в коробке передач или влияния формы кузова на скорость (разве что, автомобиль стоит в глухой пробке и водителю абсолютно нечем заняться). Однако, руль, педали, указатель поворота он будет использовать регулярно.


14. В чем заключаются преимущества и недостатки объектно-ориентированного подхода в программировании?
Преимущества:
Объектная модель вполне естественна, поскольку в первую очередь ориентирована на человеческое восприятие мира, а не на компьютерную реализацию.
Классы позволяют проводить конструирование из полезных компонентов, обладающих простыми инструментами, что позволяет абстрагироваться от деталей реализации.
Данные и операции над ними образуют определенную сущность, и они не разносятся по всей программе, как нередко бывает в случае процедурного программирования, а описываются вместе. Локализация кода и данных улучшает наглядность и удобство сопровождения программного обеспечения.
Инкапсуляция позволяет привнести свойство модульности, что облегчает распараллеливание выполнения задачи между несколькими исполнителями и обновление версий отдельных компонентов.
Возможность создавать расширяемые системы.
Использование полиморфизма оказывается полезным при:
Обработке разнородных структур данных. Программы могут работать, не различая вида объектов, что существенно упрощает код. Новые виды могут быть добавлены в любой момент.
Изменении поведения во время исполнения. На этапе исполнения один объект может быть заменен другим, что позволяет легко, без изменения кода, адаптировать алгоритм в зависимости от того, какой используется объект.
Реализации работы с наследниками. Алгоритмы можно обобщить настолько, что они уже смогут работать более чем с одним видом объектов.
Возможности описать независимые от приложения части предметной области в виде набора универсальных классов, или фреймворка, который в дальнейшем будет расширен за счет добавления частей, специфичных для конкретного приложения.
Повторное использование кода:
Сокращается время на разработку, которое может быть отдано другим задачам.
Компоненты многоразового использования обычно содержат гораздо меньше ошибок, чем вновь разработанные, ведь они уже не раз подвергались проверке.
Когда некий компонент используется сразу несколькими клиентами, улучшения, вносимые в его код, одновременно оказывают положительное влияние и на множество работающих с ним программ.
Если программа опирается на стандартные компоненты, ее структура и пользовательский интерфейс становятся более унифицированными, что облегчает ее понимание и упрощает использование.
Недостатки:
В сложных иерархиях классов поля и методы обычно наследуются с разных уровней. И не всегда легко определить, какие поля и методы фактически относятся к данному классу.
Код для обработки сообщения иногда «размазан» по многим методам (иначе говоря, обработка сообщения требует не одного, а многих методов, которые могут быть описаны в разных классах).
Документирование классов - задача более трудная, чем это было в случае процедур и модулей. Поскольку любой метод может быть переопределен, в документации должно говориться не только о том, что делает данный метод, но и о том, в каком контексте он вызывается.
Неэффективность и неэкономное распределения памяти на этапе выполнения (по причине издержек на динамическое связывание и проверки типов на этапе выполнения).
Излишняя универсальность. Часто содержится больше методов, чем это реально необходимо текущей программе. А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом.


15. Что подразумевают в плане принципов ООП выражения «является» и «имеет»?
«является» подразумевает наследование. «имеет» подразумевает ассоциацию (агрегацию или композицию).

16. В чем разница между композицией и агрегацией?
Ассоциация обозначает связь между объектами. Композиция и агрегация — частные случаи ассоциации «часть-целое».
Агрегация предполагает, что объекты связаны взаимоотношением «part-of» (часть). Композиция более строгий вариант агрегации. Дополнительно к требованию «part-of» накладывается условие, что экземпляр «части» может входить только в одно целое (или никуда не входить), в то время как в случае агрегации экземпляр «части» может входить в несколько целых.
Например, книга состоит из страниц, и мы не можем вырвать страницу из книги и вложить в другую книгу. Страницы четко привязаны к конкретной книге, поэтому это композиция. В тоже время мы можем взять и перенести книгу из одной библиотеки в другую - это уже агрегация.

Раздел - Java Core (продолжение)

17. О чем говорит ключевое слово final?
Модификатор final может применяться к переменным, параметрам методов, полям и методам класса или самим классам.
Класс не может иметь наследников;
Метод не может быть переопределен в классах наследниках;
Поле не может изменить свое значение после инициализации;
Параметры методов не могут изменять своё значение внутри метода;
Локальные переменные не могут быть изменены после присвоения им значения.

 
 
18. Какими значениями инициализируются переменные по умолчанию?
Числа инициализируются 0 или 0.0;
char — \u0000;
boolean — false;
Объекты (в том числе String) — null.
19. Что вы знаете о функции main()?
Метод main() — точка входа в программу. В приложении может быть несколько таких методов. Если метод отсутствует, то компиляция возможна, но при запуске будет получена ошибка `Error: Main method not found`.
public static void main(String[] args) {}
20. Какие логические операции и операторы вы знаете?
&: Логическое AND (И);
&&: Сокращённое AND;
|: Логическое OR (ИЛИ);
||: Сокращённое OR;
^: Логическое XOR (исключающее OR (ИЛИ));
!: Логическое унарное NOT (НЕ);
&=: AND с присваиванием;
|=: OR с присваиванием;
^=: XOR с присваиванием;
==: Равно;
!=: Не равно;
?:: Тернарный (троичный) условный оператор.
 
 
21. Что такое тернарный оператор выбора?
Тернарный условный оператор ?: - оператор, которым можно заменить некоторые конструкции операторов if-then-else.
Выражение записывается в следующей форме:
условие ? выражение1 : выражение2
Если условие выполняется, то вычисляется выражение1 и его результат становится результатом выполнения всего оператора. Если же условие равно false, то вычисляется выражение2 и его значение становится результатом работы оператора. Оба операнда выражение1 и выражение2 должны возвращать значение одинакового (или совместимого) типа.
22. Где и для чего используется модификатор abstract?
Класс, помеченный модификатором abstract, называется абстрактным классом. Такие классы могут выступать только предками для других классов. Создавать экземпляры самого абстрактного класса не разрешается. При этом наследниками абстрактного класса могут быть как другие абстрактные классы, так и классы, допускающие создание объектов.
Метод, помеченный ключевым словом abstract - абстрактный метод, т.е. метод, который не имеет реализации. Если в классе присутствует хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным.
Использование абстрактных классов и методов позволяет описать некий шаблон объекта, который должен быть реализован в других классах. В них же самих описывается лишь некое общее для всех потомков поведение.
23. Что такое абстрактный класс?

Абстрактный класс - это максимально абстрактная, очень приблизительная «заготовка» для группы будущих классов. Эту заготовку нельзя использовать в готовом виде — слишком «сырая». Но она описывает некое общее состояние и поведение, которым будут обладать будущие классы — наследники абстрактного класса.
24. Что такое интерфейс?
Интерфейс - это абстрактный тип, который используется для определения поведения, которое должны реализовывать классы. Интерфейс очень напоминает абстрактный класс, у которого все методы абстрактные. Он объявляется так же, как и класс, только используется ключевое слово interface.

Ключевое слово interface используется для создания полностью абстрактных классов. Основное предназначение интерфейса - определять каким образом мы можем использовать класс, который его реализует. Создатель интерфейса определяет имена методов, списки аргументов и типы возвращаемых значений, но не реализует их поведение. Все методы неявно объявляются как public.
Начиная с Java 8 в интерфейсах разрешается размещать реализацию методов по умолчанию default и статических static методов.
Интерфейс также может содержать и поля. В этом случае они автоматически являются публичными public, статическими static и неизменяемыми final.

25. Что такое default method в Interface?
То есть, дефолтный метод — это реализованный метод в интерфейсе, у которого есть ключевое слово default.
Например, всем известный метод stream() в интерфейсе Collection. Проверьте, этот интерфейс вовсе не так прост как кажется ;).
Или также не менее известный метод forEach() из интерфейса Iterable. Его также не был до тех пор, пока не добавили дефолтные методы.
 
 

26. Какая разница между абстрактным классом и интерфейсом? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?
В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса.
Абстрактные классы используются только тогда, когда присутствует тип отношений «is a» (является). Интерфейсы могут реализоваться классами, которые не связаны друг с другом.
Абстрактный класс - средство, позволяющее избежать написания повторяющегося кода, инструмент для частичной реализации поведения. Интерфейс - это средство выражения семантики класса, контракт, описывающий возможности. Все методы интерфейса неявно объявляются как public abstract или (начиная с Java 8) default - методами с реализацией по-умолчанию, а поля - public static final.
Интерфейсы позволяют создавать структуры типов без иерархии.
Наследуясь от абстрактного, класс «растворяет» собственную индивидуальность. Реализуя интерфейс, он расширяет собственную функциональность.
Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах. При этом все подклассы схожи между собой в части реализации, унаследованной от абстрактного класса, и отличаются лишь в части собственной реализации абстрактных методов родителя. Поэтому абстрактные классы применяются в случае построения иерархии однотипных, очень похожих друг на друга классов. В этом случае наследование от абстрактного класса, реализующего поведение объекта по умолчанию может быть полезно, так как позволяет избежать написания повторяющегося кода. Во всех остальных случаях лучше использовать интерфейсы.
 
27. Почему в некоторых интерфейсах вообще не определяют методов?
Это так называемые маркерные интерфейсы. Они просто указывают что класс относится к определенному типу. Примером может послужить интерфейс Clonable, который указывает на то, что класс поддерживает механизм клонирования.

28. Почему нельзя объявить метод интерфейса с модификатором final?
В случае интерфейсов указание модификатора final бессмысленно, т.к. все методы интерфейсов неявно объявляются как абстрактные, т.е. их невозможно выполнить, не реализовав где-то еще, а этого нельзя будет сделать, если у метода идентификатор final.

29. Что имеет более высокий уровень абстракции - класс, абстрактный класс или интерфейс?
Интерфейс
 
30. Какие есть особенности класса String?
Это неизменяемый (immutable) и финализированный тип данных;
Все объекты класса String JVM хранит в пуле строк;
Объект класса String можно получить, используя двойные кавычки;
Можно использовать оператор + для конкатенации строк;
Начиная с Java 7 строки можно использовать в конструкции switch.
 
31. Почему String неизменяемый и финализированный класс?

Есть несколько преимуществ в неизменности строк:
Пул строк возможен только потому, что строка неизменяемая, таким образом виртуальная машина сохраняет больше свободного места в Heap, поскольку разные строковые переменные указывают на одну и ту же переменную в пуле. Если бы строка была изменяемой, то интернирование строк не было бы возможным, потому что изменение значения одной переменной отразилось бы также и на остальных переменных, ссылающихся на эту строку.
Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в противном случае злоумышленник может изменить значение ссылки и вызвать проблемы в безопасности приложения.
Неизменяемость позволяет избежать синхронизации: строки безопасны для многопоточности и один экземпляр строки может быть совместно использован различными потоками.
Строки используются classloader и неизменность обеспечивает правильность загрузки класса.
Поскольку строка неизменяемая, её hashCode() кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в HashMap т.к. его обработка происходит быстрее.

 
 
 
 
32. Почему char[] предпочтительнее String для хранения пароля? (Нужно уточнить, не уверен)
С момента создания строка остаётся в пуле, до тех пор, пока не будет удалена сборщиком мусора. Поэтому, даже после окончания использования пароля, он некоторое время продолжает оставаться доступным в памяти и способа избежать этого не существует. Это представляет определённый риск для безопасности, поскольку кто-либо, имеющий доступ к памяти сможет найти пароль в виде текста. В случае использования массива символов для хранения пароля имеется возможность очистить его сразу по окончанию работы с паролем, позволяя избежать риска безопасности, свойственного строке.
33. Какая разница между String, String Builder и String Buffer?
Значения String хранятся в пуле стрингов (constant string pool). Как только будет создана строка, она появится в этом пуле. И удалить ее будет нельзя.
Например:
String name = "book";
...переменная будет ссылаться на стринг пул

Constant string pool



Если задать переменной name другое значение, получится следующее:

name = "pen";
Constant string pool



Таким образом, эти два значения так и останутся там.

String Buffer:

значения String хранятся в стеке(Stack). Если значение изменено, значит новое значение будет заменено на старое;
String Buffer синхронизирован, и поэтому он потокобезопасный;
из-за потокобезопасности скорость работы оставляет желать лучшего.
Пример:

StringBuffer name = “book”;



Как только значение name сменится, в стеке измениться значение:





StringBuilder

Точно такой же, как и StringBuffer, только он не потокобезопасный. Поэтому скорость его явно выше, чем в StringBuffer.

34. Почему строка является популярным ключом в HashMap в Java?
Поскольку строки неизменяемы, их хэш код вычисляется и кэшируется в момент создания, не требуя повторного пересчета при дальнейшем использовании. Поэтому в качестве ключа HashMap они будут обрабатываться быстрее.

35. Что делает метод intern() в классе String?
Метод intern() используется для сохранения строки в пуле строк или получения ссылки, если такая строка уже находится в пуле.

36. Можно ли использовать строки в конструкции switch?
Да, начиная с Java 7 в операторе switch можно использовать строки, ранние версии Java не поддерживают этого. При этом:
участвующие строки чувствительны к регистру;
используется метод equals() для сравнения полученного значения со значениями case, поэтому во избежание NullPointerException стоит предусмотреть проверку на null.
согласно документации, Java 7 для строк в switch, компилятор Java формирует более эффективный байткод для строк в конструкции switch, чем для сцепленных условий if-else.
 
37. Зачем нужны и какие бывают блоки инициализации?
Блоки инициализации представляют собой код, заключенный в фигурные скобки и размещаемый внутри класса вне объявления методов или конструкторов.
Существуют статические и нестатические блоки инициализации.
Блок инициализации выполняется перед инициализацией класса загрузчиком классов или созданием объекта класса с помощью конструктора.
Несколько блоков инициализации выполняются в порядке следования в коде класса.
Блок инициализации способен генерировать исключения, если их объявления перечислены в throws всех конструкторов класса.
Блок инициализации возможно создать и в анонимном классе.
38. К каким конструкциям Java применим модификатор static?
полям;
методам;
вложенным классам;
членам секции import.

39. Для чего в Java используются статические блоки инициализации?
Статические блоки инициализация используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов, в момент, предшествующий созданию объектов этого класса при помощи конструктора. Такой блок (в отличие от нестатических, принадлежащих конкретном объекту класса) принадлежит только самому классу (объекту метакласса Class).

40. Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?
Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом требуется, чтобы объявления этих исключений были перечислены в throws всех конструкторов класса. Иначе будет ошибка компиляции. Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.
В остальных случаях, взаимодействие с исключениями будет проходить так же, как и в любом другом месте. Класс не будет инициализирован, если ошибка происходит в статическом блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.

41. Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?
Если возникшее исключение - наследник RuntimeException:
для статических блоков инициализации будет выброшено java.lang.ExceptionInInitializerError;
для нестатических будет проброшено исключение-источник.
Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено java.lang.Error. Исключение: java.lang.ThreadDeath - смерть потока. В этом случае никакое исключение выброшено не будет.

42. Может ли статический метод быть переопределён или перегружен?

Перегружен - да. Всё работает точно так же, как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.
Переопределён - нет. Выбор вызываемого статического метода происходит при раннем связывании (на этапе компиляции, а не выполнения) и выполняться всегда будет родительский метод, хотя синтаксически переопределение статического метода - это вполне корректная языковая конструкция.
В целом, к статическим полям и методам рекомендуется обращаться через имя класса, а не объект.

43. Могут ли нестатические методы перегрузить статические?
Да. В итоге получится два разных метода. Статический будет принадлежать классу и будет доступен через его имя, а нестатический будет принадлежать конкретному объекту и доступен через вызов метода этого объекта.


44. Возможно ли при переопределении метода изменить: модификатор доступа, возвращаемый тип, тип аргумента или их количество, имена аргументов или их порядок; убирать, добавлять, изменять порядок следования элементов секции throws?
При переопределении метода сужать модификатор доступа не разрешается, т.к. это приведёт к нарушению принципа подстановки Барбары Лисков. Расширение уровня доступа возможно.
Можно изменять все, что не мешает компилятору понять какой метод родительского класса имеется в виду:
Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).
При изменении типа, количества, порядка следования аргументов вместо переопределения будет происходить overloading(перегрузка) метода.
Секцию throws метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Также, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет.

45. Как получить доступ к переопределенным методам родительского класса?
С помощью ключевого слова super мы можем обратиться к любому члену родительского класса - методу или полю, если они не определены с модификатором private.

super.method();


46. Можно ли объявить метод абстрактным и статическим одновременно?
Нет. В таком случае компилятор выдаст ошибку: "Illegal combination of modifiers: ‘abstract’ and ‘static’". Модификатор abstractговорит, что метод будет реализован в другом классе, а static наоборот указывает, что этот метод будет доступен по имени класса.

47. В чем разница между членом экземпляра класса и статическим членом класса?
Модификатор static говорит о том, что данный метод или поле принадлежат самому классу и доступ к ним возможен даже без создания экземпляра класса. Поля, помеченные static инициализируются при инициализации класса. На методы, объявленные как static, накладывается ряд ограничений:
Они могут вызывать только другие статические методы.
Они должны осуществлять доступ только к статическим переменным.
Они не могут ссылаться на члены типа this или super.
В отличии от статических, поля экземпляра класса принадлежат конкретному объекту и могут иметь разные значения для каждого. Вызов метода экземпляра возможен только после предварительного создания объекта класса.

48. Где разрешена инициализация статических/нестатических полей?
Статические поля можно инициализировать при объявлении, в статическом или нестатическом блоке инициализации.
Нестатические поля можно инициализировать при объявлении, в нестатическом блоке инициализации или в конструкторе.

49. Что такое «анонимные классы»? Где они применяются?
Это вложенный локальный класс без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений. Создание экземпляра анонимного класса происходит одновременно с его объявлением. В зависимости от местоположения анонимный класс ведет себя как статический либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.
Анонимные классы имеют несколько ограничений:
Их использование разрешено только в одном месте программы - месте его создания;
Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;
Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа.
Анонимные классы обычно применяются для:
создания объекта функции (function object), например, реализация интерфейса Comparator;
создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;
в статическом методе генерации;
инициализации открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.


50. Что такое Heap и Stack память в Java? Какая разница между ними?
Heap (куча) используется Java Runtime для выделения памяти под объекты и классы. Создание нового объекта также происходит в куче. Это же является областью работы сборщика мусора. Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться из любой части приложения.
Stack (стек) это область хранения данных также находящееся в общей оперативной памяти (RAM). Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода. Размер стековой памяти намного меньше объема памяти в куче. Стек в Java работает по схеме LIFO (Последний-зашел-Первый-вышел)
Различия между Heap и Stack памятью:
Куча используется всеми частями приложения, в то время как стек используется только одним потоком исполнения программы.
Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится лишь ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.
Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других потоков.
Стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы программы.
Если память стека полностью занята, то Java Runtime бросает исключение java.lang.StackOverflowError. Если заполнена память кучи, то бросается исключение java.lang.OutOfMemoryError: Java Heap Space.
Размер памяти стека намного меньше памяти в куче.
Из-за простоты распределения памяти, стековая память работает намного быстрее кучи.
Для определения начального и максимального размера памяти в куче используются -Xms и -Xmx опции JVM. Для стека определить размер памяти можно с помощью опции -Xss.


51. Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных в куче?
Не совсем. Примитивное поле экземпляра класса хранится не в стеке, а в куче. Любой объект (всё, что явно или неявно создаётся при помощи оператора new) хранится в куче.

52. Каким образом передаются переменные в методы, по значению или по ссылке?
В Java параметры всегда передаются только по значению, что определяется как «скопировать значение и передать копию». С примитивами это будет копия содержимого. Со ссылками - тоже копия содержимого, т.е. копия ссылки. При этом внутренние члены ссылочных типов через такую копию изменить возможно, а вот саму ссылку, указывающую на экземпляр - нет.

53. Для чего нужен сборщик мусора?
Сборщик мусора (Garbage Collector) должен делать всего две вещи:
Находить мусор - неиспользуемые объекты. (Объект считается неиспользуемым, если ни одна из сущностей в коде, выполняемом в данный момент, не содержит ссылок на него, либо цепочка ссылок, которая могла бы связать объект с некоторой сущностью приложения, обрывается);
Освобождать память от мусора.
Существует два подхода к обнаружению мусора:
Reference counting;
Tracing
Reference counting (подсчёт ссылок). Суть этого подхода состоит в том, что каждый объект имеет счетчик. Счетчик хранит информацию о том, сколько ссылок указывает на объект. Когда ссылка уничтожается, счетчик уменьшается. Если значение счетчика равно нулю, - объект можно считать мусором. Главным минусом такого подхода является сложность обеспечения точности счетчика. Также при таком подходе сложно выявлять циклические зависимости (когда два объекта указывают друг на друга, но ни один живой объект на них не ссылается), что приводит к утечкам памяти.
Главная идея подхода Tracing (трассировка) состоит в утверждении, что живыми могут считаться только те объекты, до которых мы можем добраться из корневых точек (GC Root) и те объекты, которые доступны с живого объекта. Всё остальное - мусор.
Существует 4 типа корневых точки:
Локальные переменные и параметры методов;
Потоки;
Статические переменные;
Ссылки из JNI.
Самое простое java приложение будет иметь корневые точки:
Локальные переменные внутри main() метода и параметры main() метода;
Поток который выполняет main();
Статические переменные класса, внутри которого находится main() метод.
Таким образом, если мы представим все объекты и ссылки между ними как дерево, то нам нужно будет пройти с корневых узлов (точек) по всем рёбрам. При этом узлы, до которых мы сможем добраться - не мусор, все остальные - мусор. При таком подходе циклические зависимости легко выявляются. HotSpot VM использует именно такой подход
Для очистки памяти от мусора существуют два основных метода:
Copying collectors
Mark-and-sweep
При copying collectors подходе память делится на две части «from-space» и «to-space», при этом сам принцип работы такой:
Объекты создаются в «from-space»;
Когда «from-space» заполняется, приложение приостанавливается;
Запускается сборщик мусора. Находятся живые объекты в «from-space» и копируются в «to-space»;
Когда все объекты скопированы «from-space» полностью очищается;
«to-space» и «from-space» меняются местами.
Главный плюс такого подхода в том, что объекты плотно забивают память. Минусы подхода:
Приложение должно быть остановлено на время, необходимое для полного прохождения цикла сборки мусора;
В худшем случае (когда все объекты живые) «form-space» и «to-space» будут обязаны быть одинакового размера.
Алгоритм работы mark-and-sweep можно описать так:
Объекты создаются в памяти;
В момент, когда нужно запустить сборщик мусора приложение приостанавливается;
Сборщик проходится по дереву объектов, помечая живые объекты;
Сборщик проходится по всей памяти, находя все не отмеченные куски памяти и сохраняя их в «free list»;
Когда новые объекты начинают создаваться они создаются в памяти доступной во «free list».
Минусы этого способа:
Приложение не работает пока происходит сборка мусора;
Время остановки напрямую зависит от размеров памяти и количества объектов;
Если не использовать «compacting» память будет использоваться не эффективно.
Сборщики мусора HotSpot VM используют комбинированный подход Generational Garbage Collection, который позволяет использовать разные алгоритмы для разных этапов сборки мусора. Этот подход опирается на том, что:
большинство создаваемых объектов быстро становятся мусором;
существует мало связей между объектами, которые были созданы в прошлом и только что созданными объектами.


54. Как работает сборщик мусора?
Механизм сборки мусора - это процесс освобождения места в куче, для возможности добавления новых объектов.
Объекты создаются посредством оператора new, тем самым присваивая объекту ссылку. Для окончания работы с объектом достаточно просто перестать на него ссылаться, например, присвоив переменной ссылку на другой объект или значение null; прекратить выполнение метода, чтобы его локальные переменные завершили свое существование естественным образом. Объекты, ссылки на которые отсутствуют, принято называть мусором (garbage), который будет удален.
Виртуальная машина Java, применяя механизм сборки мусора, гарантирует, что любой объект, обладающий ссылками, остается в памяти — все объекты, которые недостижимы из исполняемого кода, ввиду отсутствия ссылок на них, удаляются с высвобождением отведенной для них памяти. Точнее говоря, объект не попадает в сферу действия процесса сборки мусора, если он достижим посредством цепочки ссылок, начиная с корневой (GC Root) ссылки, т.е. ссылки, непосредственно существующей в выполняемом коде.
Память освобождается сборщиком мусора по его собственному «усмотрению». Программа может успешно завершить работу, не исчерпав ресурсов свободной памяти или даже не приблизившись к этой черте и поэтому ей так и не потребуются «услуги» сборщика мусора.
Мусор собирается системой автоматически, без вмешательства пользователя или программиста, но это не значит, что этот процесс не требует внимания вовсе. Необходимость создания и удаления большого количества объектов существенным образом сказывается на производительности приложений и, если быстродействие программы является важным фактором, следует тщательно обдумывать решения, связанные с созданием объектов, — это, в свою очередь, уменьшит и объем мусора, подлежащего утилизации.







55. Что такое «пул строк»?
Пул строк – это набор строк, хранящийся в Heap.
Пул строк возможен благодаря неизменяемости строк в Java и реализации идеи интернирования строк;
Пул строк помогает экономить память, но по этой же причине создание строки занимает больше времени;
Когда для создания строки используются ", то сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка на неё;
При использовании оператора new создаётся новый объект String. Затем при помощи метода intern() эту строку можно поместить в пул или же получить из пула ссылку на другой объект String с таким же значением;
Пул строк является примером паттерна «Приспособленец» (Flyweight).

56. Чем отличаются final, finally и finalize()?
Модификатор final:
Класс не может иметь наследников;
Метод не может быть переопределен в классах наследниках;
Поле не может изменить свое значение после инициализации;
Локальные переменные не могут быть изменены после присвоения им значения;
Параметры методов не могут изменять своё значение внутри метода.
Оператор finally гарантирует, что определенный в нём участок кода будет выполнен независимо от того, какие исключения были возбуждены и перехвачены в блоке try-catch.
Метод finalize() вызывается перед тем как сборщик мусора будет проводить удаление объекта.
 
57. Расскажите про приведение типов. Что такое понижение и повышение типа?
Java является строго типизированным языком программирования, а это означает, то что каждое выражение и каждая переменная имеет строго определенный тип уже на момент компиляции. Однако определен механизм приведения типов (casting) - способ преобразования значения переменной одного типа в значение другого типа.
В Java существуют несколько разновидностей приведения:
Тождественное (identity). Преобразование выражения любого типа к точно такому же типу всегда допустимо и происходит автоматически.
Расширение (повышение, upcasting) примитивного типа (widening primitive). Означает, что осуществляется переход от менее емкого типа к более ёмкому. Например, от типа byte (длина 1 байт) к типу int (длина 4 байта). Такие преобразование безопасны в том смысле, что новый тип всегда гарантировано вмещает в себя все данные, которые хранились в старом типе и таким образом не происходит потери данных. Этот тип приведения всегда допустим и происходит автоматически.
Сужение (понижение, downcasting) примитивного типа (narrowing primitive). Означает, что переход осуществляется от более емкого типа к менее емкому. При таком преобразовании есть риск потерять данные. Например, если число типа intбыло больше 127, то при приведении его к byte значения битов старше восьмого будут потеряны. В Java такое преобразование должно совершаться явным образом, при этом все старшие биты, не умещающиеся в новом типе, просто отбрасываются - никакого округления или других действий для получения более корректного результата не производится.
Расширение объектного типа (widening reference). Означает неявное восходящее приведение типов или переход от более конкретного типа к менее конкретному, т.е. переход от потомка к предку. Разрешено всегда и происходит автоматически.
Сужение объектного типа (narrowing reference). Означает нисходящее приведение, то есть приведение от предка к потомку (подтипу). Возможно только если исходная переменная является подтипом приводимого типа. При несоответствии типов в момент выполнения выбрасывается исключение ClassCastException. Требует явного указания типа.
Преобразование к строке (to String). Любой тип может быть приведен к строке, т.е. к экземпляру класса String.
Запрещенные преобразования (forbidden). Не все приведения между произвольными типами допустимы. Например, к запрещенным преобразованиям относятся приведения от любого ссылочного типа к примитивному и наоборот (кроме преобразования к строке). Кроме того, невозможно привести друг к другу классы, находящиеся на разных ветвях дерева наследования и т.п.
При приведении ссылочных типов с самим объектом ничего не происходит, - меняется лишь тип ссылки, через которую происходит обращение к объекту.
Для проверки возможности приведения нужно воспользоваться оператором instanceof:
Parent parent = new Child();
if (parent instanceof Child) {
    Child child = (Child) parent;
}


58. Когда в приложении может быть выброшено исключение ClassCastException?
ClassCastException (потомок RuntimeException) - исключение, которое будет выброшено при ошибке приведения типа.


59. Что такое autoboxing («автоупаковка») в Java и каковы правила упаковки примитивных типов в классы-обертки?
Автоупаковка - это механизм неявной инициализации объектов классов-оберток (Byte, Short, Integer, Long, Float, Double, Character, Boolean) значениями соответствующих им исходных примитивных типов (byte, short, int...), без явного использования конструктора класса.
Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью оператора =), либо при передаче примитива в параметры метода (типа класса-обертки).
Автоупаковке в классы-обертки могут быть подвергнуты как переменные примитивных типов, так и константы времени компиляции (литералы и final-примитивы). При этом литералы должны быть синтаксически корректными для инициализации переменной исходного примитивного типа.
Автоупаковка переменных примитивных типов требует точного соответствия типа исходного примитива типу класса-обертки. Например, попытка упаковать переменную типа byte в Short, без предварительного явного приведения byte в shortвызовет ошибку компиляции.
Автоупаковка констант примитивных типов допускает более широкие границы соответствия. В этом случае компилятор способен предварительно осуществлять неявное расширение/сужение типа примитивов:
неявное расширение/сужение исходного типа примитива до типа примитива, соответствующего классу-обертке (для преобразования int в Byte, сначала компилятор самостоятельно неявно сужает int к byte)
автоупаковку примитива в соответствующий класс-обертку. Однако, в этом случае существуют два дополнительных ограничения: a) присвоение примитива обертке может производится только оператором = (нельзя передать такой примитив в параметры метода без явного приведения типов) b) тип левого операнда не должен быть старше чем Character, тип правого не должен старше, чем int: допустимо расширение/сужение byte в/из short, byte в/из char, short в/из char и только сужение byte из int, short из int, char из int. Все остальные варианты требуют явного приведения типов).
Дополнительной особенностью целочисленных классов-оберток, созданных автоупаковкой констант в диапазоне -128 ... +127является то, что они кэшируются JVM. Поэтому такие обертки с одинаковыми значениями будут являться ссылками на один объект.

60. Дайте определение понятию «конструктор»
Конструктор — это специальный метод, у которого отсутствует возвращаемый тип и который имеет то же имя, что и класс, в котором он используется. Конструктор вызывается при создании нового объекта класса и определяет действия необходимые для его инициализации.
61. Что такое «конструктор по умолчанию»?
Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый «конструктор по умолчанию».
public class ClassName() {}
Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно.
62. Чем отличаются конструктор по-умолчанию, конструктор копирования и конструктор с параметрами?
У конструктора по умолчанию отсутствуют какие-либо аргументы. Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания его клона. Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для инициализации полей класса).

63. Где и как вы можете использовать приватный конструктор?
Приватный (помеченный ключевым словом private, скрытый) конструктор может использоваться публичным статическим методом генерации объектов данного класса. Также доступ к нему разрешён вложенным классам и может использоваться для их нужд.

64. Зачем нужен equals(). Чем он отличается от операции ==?
Метод equals() - определяет отношение эквивалентности объектов.
При сравнении объектов с помощью == сравнение происходит лишь между ссылками. При сравнении по переопределённому разработчиком equals() - по внутреннему состоянию объектов.
65. Какими свойствами обладает порождаемое equals() отношение эквивалентности?
Рефлексивность: для любой ссылки на значение x, x.equals(x) вернет true;
Симметричность: для любых ссылок на значения x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) возвращает true.
Транзитивность: для любых ссылок на значения x, y и z, если x.equals(y) и y.equals(z) возвращают true, тогда и x.equals(z) вернёт true;
Непротиворечивость: для любых ссылок на значения х и у, если несколько раз вызвать х.equals(y), постоянно будет возвращаться значение true либо постоянно будет возвращаться значение false при условии, что никакая информация, используемая при сравнении объектов, не поменялась.
Для любой ненулевой ссылки на значение х выражение х.equals(null) должно возвращать false.

66. Правила переопределения метода Object.equals()
Использование оператора == для проверки, является ли аргумент ссылкой на указанный объект. Если является, возвращается true. Если сравниваемый объект == null, должно вернуться false.
Использование оператор instanceof и вызова метода getClass() для проверки, имеет ли аргумент правильный тип. Если не имеет, возвращается false.
Приведение аргумента к правильному типу. Поскольку эта операция следует за проверкой instanceof она гарантированно будет выполнена.
Обход всех значимых полей класса и проверка того, что значение поля в текущем объекте и значение того же поля в проверяемом на эквивалентность аргументе соответствуют друг другу. Если проверки для всех полей прошли успешно, возвращается результат true, в противном случае - false.
По окончанию переопределения метода equals() следует проверить: является ли порождаемое отношение эквивалентности рефлексивным, симметричным, транзитивным и непротиворечивым? Если ответ отрицательный, метод подлежит соответствующей правке.


67. Если equals() переопределен, есть ли какие-либо другие методы, которые следует переопределить?
Равные объекты должны возвращать одинаковые хэш коды. При переопределении equals() нужно обязательно переопределять и метод hashCode().

68. Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?
Классы и методы, которые используют правила этого контракта могут работать некорректно. Так для HashMap это может привести к тому, что пара «ключ-значение», которая была в неё помещена при использовании нового экземпляра ключа не будет в ней найдена.

69. Каким образом реализованы методы hashCode() и equals() в классе Object?
Реализация метода Object.equals() сводится к проверке на равенство двух ссылок:


public boolean equals(Object obj) {
  return (this == obj);
}


Реализация метода Object.hashCode() описана как native, т.е. определенной не с помощью Java кода и обычно возвращает адрес объекта в памяти:

public native int hashCode();



70. Для чего нужен метод hashCode()?
Метод hashCode() необходим для вычисления хэш кода переданного в качестве входного параметра объекта. В Java это целое число, в более широком смысле - битовая строка фиксированной длины, полученная из массива произвольной длины. Этот метод реализован таким образом, что для одного и того же входного объекта, хэш код всегда будет одинаковым. Следует понимать, что в Java множество возможных хэш кодов ограничено типом int, а множество объектов ничем не ограничено. Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть:
если хэш коды разные, то и объекты гарантированно разные;
если хэш коды равны, то объекты не обязательно равны(могут быть разные).

71. Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?
Общий совет: выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например, такие как id, uuid. При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().

72. Могут ли у разных объектов быть одинаковые hashCode()?
Да, могут. Метод hashCode() не гарантирует уникальность возвращаемого значения. Ситуация, когда у разных объектов одинаковые хэш коды называется коллизией. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хэш кода.


73. Опишите иерархию исключений.
Исключения делятся на несколько классов, но все они имеют общего предка — класс Throwable, потомками которого являются классы Exception и Error.
Ошибки (Errors) представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память доступная виртуальной машине.
Исключения (Exceptions) являются результатом проблем в программе, которые в принципе решаемы, предсказуемы и последствия которых возможно устранить внутри программы. Например, произошло деление целого числа на ноль.


74. Что такое checked и unchecked exception?
В Java все исключения делятся на два типа:
checked (контролируемые/проверяемые исключения) должны обрабатываться блоком catch или описываться в заголовке метода (например, throws IOException). Наличие такого обработчика/модификатора в заголовке метода проверяется на этапе компиляции;
unchecked (неконтролируемые/непроверяемые исключения), к которым относятся ошибки Error (например, OutOfMemoryError), обрабатывать которые не рекомендуется и исключения времени выполнения, представленные классом RuntimeException и его наследниками (например, NullPointerException), которые могут не обрабатываться блоком catch и не быть описанными в заголовке метода.


75. Какой оператор позволяет принудительно выбросить исключение?
Это оператор throw:

throw new Exception();


76. О чем говорит ключевое слово throws?
Модификатор throws прописывается в заголовке метода и указывает на то, что метод потенциально может выбросить исключение с указанным типом.


77. Какие существуют unchecked exception?
Наиболее часто встречающиеся: ArithmeticException, ClassCastException, ConcurrentModificationException, IllegalArgumentException, IllegalStateException, IndexOutOfBoundsException, NoSuchElementException, NullPointerException, UnsupportedOperationException.





78. Что представляет из себя ошибки класса Error?
Ошибки (Error) представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует пытаться обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память, доступная виртуальной машине. Программа дополнительную память всё равно не сможет обеспечить для JVM.


79. Опишите работу блока try-catch-finally.
try — данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.catch — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений в случае их возникновения. finally — ключевое слово для отметки начала блока кода, который является дополнительным. Этот блок помещается после последнего блока catch. Управление передаётся в блок finally в любом случае, было выброшено исключение или нет.
Общий вид конструкции для обработки исключительной ситуации выглядит следующим образом:
try { 
    //код, который потенциально может привести к исключительной ситуации 
} 
catch(SomeException e ) { //в скобках указывается класс конкретной ожидаемой ошибки  
    //код обработки исключительной ситуации
} 
finally {
    //необязательный блок, код которого выполняется в любом случае
}



 
 
80. Что такое механизм try-with-resources?
Данная конструкция, которая появилась в Java 7, позволяет использовать блок try-catch не заботясь о закрытии ресурсов, используемых в данном сегменте кода. Ресурсы объявляются в скобках сразу после try, а компилятор уже сам неявно создаёт секцию finally, в которой и происходит освобождение занятых в блоке ресурсов. Под ресурсами подразумеваются сущности, реализующие интерфейс java.lang.Autocloseable.
Общий вид конструкции:
try(/*объявление ресурсов*/) {
    //...
} catch(Exception ex) {
    //...
} finally {
    //...
}
Стоит заметить, что блоки catch и явный finally выполняются уже после того, как закрываются ресурсы в неявном finally.
81. Возможно ли использование блока try-finally (без catch)?

Такая запись допустима, но смысла в такой записи не так много, всё же лучше иметь блок catch, в котором будет обрабатываться необходимое исключение.





